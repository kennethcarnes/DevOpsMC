# What is Git?
Git is a Distributed Version Control System. Developers use synchronizing mechanisms like pull ("Tell me the changes") and push ("Push these changes"). The system of record is the remote origin repository (like Github or Azure Repos).

Using this system, Developers work with a local copy of the entire repository, but they have to communicate and follow a process and minimize conflict. There will be conflicts, but many can be avoided if developers consistently commit and push their new code from their local machine to the remote origin.

![distributed](../Images/distributed.png)

# Initial Configuration
To enable the source control features within VSCode, you must add a line to the JSON setting to tell VSCode where ```git.exe``` is

![settings](../Images/settings.png)

To start using git, configure the user ```username``` and ```user.email```
```powershell
#Check version
git --version

#Config repository credentials
git config --global --list
git config user.name
git config user.email


#Turn any folder into a repo, creates .git folder
git status
git init
git status

#View the hidden folder
Get-ChildItem -Force   #notice the .git

#Clone the DevOps Master Class Repo into the current folder
git clone https://github.com/johnthebrit/DevOpsMC.git .

#Clone into a new subfolder auto created under current path
git clone https://github.com/johnthebrit/DevOpsMC.git

#This is very common to use instead of master
git config --global init.defaultBranch main 

#When you create a new repo you can override the default initial branch
git init --initial-branch=main
git init -b main

#See config of remote origin
git config --list --show-origin
```

# Working with ```commit``` in Git

A commit is a complete snapshot of the entire repository. It represents a specific point in time. The internal workings of git use a hierarchical structure of folder and file objects in the filesystem to track changes and maintain integrity.
## Every commit includes these components:
| Component | Description                             |
| --------- | --------------------------------------- |
| tree      | a list of .zlib compressed file objects |
| blob(s)   | 1 blob for each file in the repo        |
| object(s) | 1 object for each commit                |
| metdata   | author, parent                          |
| parent    | the next commit after changes are made  |

![commit](/Images/commit.png)

## Use ```git add .``` to stage any changes to the next commit 
```powershell
#Pay attention to the current .git folder content, especially the objects folder
git add .
#Notice we now have a new object in a 2 character folder name with 38 character name, i.e. 40 character hash
git status
git diff --cached #Difference between staged and what is commited
git commit -m "Initial testfile.txt commit"
#We have two new objects created! The path and the commit itself
```
![git add .2](../images/gitadd.2.png)

###  Alternatively, you can combine the add and commit with a single command
```powershell
git commit -am "Initial testfile.txt commit"
#or even
git commit -a -m "Initial testfile.txt commit"
```

# Maintaining integrity in Git
Git maintains integrity of the version history by generating a unique 40 character SHA-1 hash for the blob and objects associated. Everything is an object in the .git filesystem. Git shards each unique 40 character hash into a folder with a 2 character name and a 38 character object inside:
```
ðŸ“¦repo
 â”£ ðŸ“‚.git
 â”ƒ â”£ ðŸ“‚objects
 â”ƒ â”ƒ â”£ðŸ“‚object (2 character hash)
 â”ƒ â”ƒ â”ƒ â”—ðŸ“œobject (38 character hash)
 â”ƒ â”ƒ â”£ðŸ“‚object
 â”ƒ â”ƒ â”ƒ â”—ðŸ“œobject
 â”ƒ â”ƒ â”£ðŸ“‚object
 â”— â”— â”— â”—ðŸ“œobject
```

![git add .](../Images/gitadd..png)


# View metadata in Git
## View details with ```git log```
![gitlog](/Images/gitlog.png)

## View type with ```git cat-file -t```
```powershell
#look at the type
git cat-file -t <first 7 of the hash shown for the commit>
```
![type](/Images/type.png)

## View content with ```git cat-file -p```
```powershell
#look at the content
git cat-file -p <first 7 of the hash shown for the commit>
```
![commit](/Images/content.png)

## Example with a tree
```powershell
#look at the type
git cat-file -t <first 7 of the hash shown for the commit>
#look at the content. Notice here it points the blob we saw created before and now has a file name
git cat-file -p <first 5 of the hash shown for the tree in commit file>
```
![tree](/Images/treecontent.png)

## Example with a blob
![blob](/Images/blob.png)

# Git only stores unique content
Since the unique hash of a blob is created with file data, a duplicate file would result in both files being tied to the same blob. Thus, Git will not create duplicate blobs for duplicate files.
```powershell
#Lets prove a point about it only storing unique content
Copy-Item .\testfile.txt .\testfile2.txt
git add .
#what new object do we have? Nothing.
git status
git commit -m "testfile2.txt added"
#We have new files. Look again
```

![uniquecontent](../Images/uniquecontent.png)

# Working with ```HEAD``` in Git
How does Git know which commit a dev is working on? When a dev is working in VSCode, they are working on a branch, which is always pointing to a particular commit. In other words, A branch is just a reference to a certain commit. The way git "knows" what you are working on is by using the HEAD.

![refs](../Images/refs.png)

## 
The ```ðŸ“‚heads``` folder stores all of the branches. While the ```ðŸ“œHEAD``` file stores the reference. In this example, ```HEAD``` is pointing to ```main```, and ```main``` is referencing a commit.
```
ðŸ“¦repo
 â”£ ðŸ“‚.git
 â”ƒ â”£ ðŸ“‚refs
 â”ƒ â”ƒ â”£ðŸ“‚heads
 â”ƒ â”ƒ â”ƒ â”—ðŸ“œmain
 â”— â”— ðŸ“œHEAD
```

## Example

### ```HEAD``` is referencing ```main```
![headreference](../Images/headreference.png)

### ```main``` is referencing a ```commit```
![head](../Images/head.png)





# Staging in Git
Devs are often working on numerous parts of a project, and will want to be precise with what they are committing, and where they are commiting it to.Staging is the process of using ```git add .``` to decide what files to include in a particular ```commit```

![staging](../Images/staging.png)

### Use ```git status``` to see what is staged
```powershell
#Modify a file and stage
code .\testfile.txt
git add testfile.txt
git status
#add a 3rd file but don't stage
code .\testfile3.txt
git status

git commit -m "updated testfile"
git status
#notice our untracked file, i.e. working is not changed but staging is now matching the repo
```

### Create a `function` with `git log` to nice view of the history of a branch
 ```powershell
git log --oneline --graph --decorate --all   #I will be using this a lot

#Create a function for nice git log command
function gitgraph {git log --oneline --graph --decorate --all}

#Could add this to your profile
code $profile
```
![gitgraph](../Images/gitgraph.png)

### Use `git log -p` to view differences between various files in a commit
```powershell
#We can look at the changes
git log -p #also shows the diff/patch between the commits :q
```

### Use `git diff` to view differences between commits
```powershell
git diff <commit>..<commit> #diff between specific commits
#Remember the complete snapshot is stored. All diffs are generated at time of command execution
```
![gitdiff](../Images/gitdiff.png)

### Use `git diff --cached` to view difference of what is staged and HEAD
```powershell
#Between what is staged and the HEAD commit (i.e. the REPO). Could also use --staged which is synonym of --cached
git diff --cached
```

### Use `git diff HEAD` to see the difference between the working and last commit (i.e. HEAD)
```powershell
#Between working and the last commit (i.e. head)
git diff HEAD #basically the sum of the above two)
```
![differences](../Images/differences.png)

## Remove something from staging




## Use `git rm` to delete from staging and working directory
```powershell
#stage the removal (which will also delete from working)
git rm <file>
#Then you need to commit as normal
git commit -m "Removed file x"
```
### Example
```powershell
code testfile4.txt
git add testfile4.txt
git commit -m "adding testfile4.txt"
git status
git rm testfile4.txt
git status #Note the delete is staged
ls #its gone from stage AND my working
git commit -m "removed testfile4.txt"
```

![gitrm](../Images/gitrm.png)
![ls](/images/ls.png)



## Use `git rm --cached` to delete from staging, but not delete from working directory
```powershell
#to ONLY stage the remove (but not delete from working)
git rm --cached <file>
#Could also just delete from working then "add" all changes
git add .
```

## Use `git reset` to reset staging and match the last commit
```powershell
#Remove all staged content. This is actually using --mixed which is default. More later
git reset
#It does this by setting staged to match the last commit
#It does NOT change your working dir
git reset --hard
#Would also change your working directory to match!
```
![gitreset](../Images/gitreset.png)

## Use `git restore` to reset individual files
```powershell
#Can reset individual files
code testfile.txt
git add testfile.txt
git status
#Restore version in staged (from last commit HEAD) but NOT working
git restore --staged testfile.txt
git status
#Restore working from stage
git restore testfile.txt
git status
code testfile.txt
#Restore to stage and working from last commit
git restore --staged --worktree testfile.txt
#Full version but not required is to say from where by this is default anyway but could specify different
git restore --source=HEAD --staged --worktree testfile.txt
111


# Branch
- A pointer to a certain commit
